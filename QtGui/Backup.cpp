//
//  ProBlobDetection.cpp
//  OpencvTut
//
//  Created by Dehan on 4/20/15.
//  Copyright (c) 2015 nephelium. All rights reserved.
//
#include <iostream>

#include "mysql_connection.h"
#include "mysql_driver.h"
#include <cppconn/driver.h>
#include <cppconn/exception.h>
#include <cppconn/resultset.h>
#include <cppconn/statement.h>
#include <QtWidgets/QApplication>

#include <QtCore\QFileInfo>
#include <QtWidgets\qlabel.h>
#include <fstream>
#include <sys/stat.h>
#include <QtCore\QCoreApplication>
#include <QtCore\qdir.h>
#include <QtCore\QDebug>
#include <QtCore\QString>
#include <stdlib.h>


#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/core/core.hpp"
#include "opencv2/objdetect/objdetect.hpp"
#include <opencv2/video/background_segm.hpp>

#include "BlobDetection.h"

#include <stdio.h>
#include <time.h>
using namespace cv;
using namespace std;
void getDiffInVideo();
void drawHist();
Mat drawHist(Mat greyImage);
Mat src;
Mat dst;
Mat resizedFrame;
Mat processedFrame;
Mat edgeDetected;

Mat savedImage;
Mat savedHist;
RNG rng(12345);

///Removes any dir if exists
void make_directory(QString path);

void make_directory(QString path){

	QDir directory(path);
	if (!directory.exists())
	{
		qDebug() << "Creating " << directory << "directory";
		directory.mkpath(path);
	}
	else
	{
		qDebug() << path << " already exists";
		directory.setNameFilters(QStringList() << "*.*");
		directory.setFilter(QDir::Files);
		foreach(QString dirFile, directory.entryList())
		{
			directory.remove(dirFile);
		}
	}
}

//global variables
Mat frame; //current frame

int frameCounter = 0;
int main()
{
	BlobDetection blb;

	//blb.
	/* The behavior of mkdir is undefined for anything other than the "permission" bits */
	QString path = "C:\\Projects\\Output";
	QString path_correct = "C:\\Projects\\Output\\file1\\correctX";
	QString path_non = "C:\\Projects\\Output\\file1\\nonX";
	//make_directory(path_correct);
	//make_directory(path_non);
	//make_directory(path);

	Mat frame; //current frame
	Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
	//Mat TestImg;
	Ptr< BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

	pMOG2 = new BackgroundSubtractorMOG2(300, 32, true);//300,0.0);

	Ptr< BackgroundSubtractor> pMOG2Pointer; //MOG2 Background subtractor
	pMOG2Pointer = new BackgroundSubtractorMOG2(300, 32, true);//300,0.0);

	string fileName = "C:\\Projects\\PRG6.avi";
	VideoCapture stream1(fileName);

	//morphology element
	Mat element = getStructuringElement(MORPH_RECT, Size(7, 7), Point(3, 3));
	bool flag = true;



	float loopCounter = 1;
	float averageTime = 0;
	int skippedFrames = 0;
	int count = 0;
	for (int i = 0; i < skippedFrames; i++)
	{
		stream1.grab();

	}
	while (true) {


		clock_t t = clock();
		if (!(stream1.read(frame)))
			break;

		vector< vector< Point> > contours;
		BlobDetection blbDetect;
		resize(frame, frame, Size(frame.size().width, frame.size().height));
		Mat originalFrame = frame.clone();


		contours = blbDetect.detectContours(frame, pMOG2Pointer, fgMaskMOG2);
		vector< vector< Point> >::iterator itc = contours.begin();


		///CONVEX HULL TESTING
		//Mat threshold_output;
		vector<Vec4i> hierarchy;

		/// Find the convex hull object for each contour
		//vector<vector<Point> >hull(contours.size());
		/*
		for (int i = 0; i < contours.size(); i++)
		{
		convexHull(Mat(contours[i]), hull[i], false);
		}

		//Find bounding rectangle
		vector<Rect> boundRect(contours.size());
		for (int i = 0; i < contours.size(); i++)
		{
		approxPolyDP(Mat(contours[i]), contours[i], 3, true);
		boundRect[i] = boundingRect(Mat(contours[i]));
		}


		/// Draw contours + hull results
		Mat drawing = Mat::zeros(frame.size(), CV_8UC3);
		Mat drawing2 = Mat::zeros(frame.size(), CV_8UC3);

		Mat mask = Mat::zeros(frame.size(), CV_8UC3);
		Mat mask2 = Mat::zeros(frame.size(), CV_8UC3);

		floodFill(drawing, Point(), Scalar(255, 255, 255));
		floodFill(drawing2, Point(), Scalar(255, 255, 255));

		for (int i = 0; i< contours.size(); i++)
		{
		Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		//drawContours( drawing2, contours, i, color, 1, 8, vector<Vec4i>(), 0, Point() );
		drawContours(drawing, hull, i, color, 1, 8, vector<Vec4i>(), 0, Point());
		rectangle(drawing2, boundRect[i].tl(), boundRect[i].br(), color, 2, 8, 0);

		}
		floodFill(drawing, Point(), Scalar(0, 0, 0));
		floodFill(drawing2, Point(), Scalar(0, 0, 0));
		originalFrame.copyTo(mask, drawing); // 'image' is the image you used to compute the contours.
		originalFrame.copyTo(mask2, drawing2); // 'image' is the image you used to compute the contours.
		*/
		//imshow("hulls", drawing);
		//imshow("mask", mask);

		//imshow("hulls2", drawing2);
		//imshow("mask2", mask2);
		cvWaitKey(1);
		////////


		vector<vector<Point> >hulls(contours.size());
		vector<Rect> boundRects(contours.size());

		vector<Point> hull;
		Rect boundRect;
		vector<Point> contourBuffer;
		vector<Point> currentContour;
		for (int i = 0; i < contours.size(); i++)
		{
			Mat hullDrawing = Mat::zeros(frame.size(), CV_8UC3);
			Mat mask = Mat::zeros(frame.size(), CV_8UC3);
			floodFill(hullDrawing, Point(), Scalar(255, 255, 255));
			Mat contourRegionConvex;
			Mat contourRegionBox;
			Mat contourRegionConvexMask;
			Mat imageROI;

			Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			currentContour = contours[i];
			Rect roi = boundingRect(currentContour);

			convexHull(Mat(currentContour), hull, false);
			hulls.push_back(hull);
			drawContours(hullDrawing, hulls, i, color, 1, 8, vector<Vec4i>(), 0, Point());
			hulls.clear();

			/*approxPolyDP(Mat(currentContour), contourBuffer, 3, true);
			boundRect = boundingRect(Mat(contourBuffer));
			rectangle(drawing2, boundRect.tl(), boundRect.br(), color, 2, 8, 0);*/

			// Get bounding box for contour


			//Copy the relevant pixels
			originalFrame.copyTo(mask, hullDrawing);
			//originalFrame.copyTo(mask2, drawing2);
			originalFrame.copyTo(imageROI, mask);
			imshow("imageROI", imageROI);
			imshow("mask", mask);
			imshow("hullDrawing", hullDrawing);


			//Crop the region of interest
			contourRegionConvex = imageROI(roi);
			contourRegionConvexMask = hullDrawing(roi);
			contourRegionBox = originalFrame(roi);
			imshow("contourRegionConvex", contourRegionConvex);
			imshow("contourRegionConvexMask", contourRegionConvexMask);
			imshow("contourRegionBox", contourRegionBox);

			cvWaitKey(1);



			time_t seconds;
			time(&seconds);
			stringstream ss;
			ss << seconds;
			string ts = ss.str();
			double heightToWidthRatio = static_cast<double>(roi.height) / static_cast<double>(roi.width);
			if (roi.width > 30 && roi.width < 100 && roi.height>30)
			{
				if (heightToWidthRatio > 1.3)
				{
					string number = "";

					if (count < 10){
						number = "000" + to_string(count);

					}
					else if (count < 100){
						number = "00" + to_string(count);
					}
					else if (count < 1000){
						number = "0" + to_string(count);
					}
					else{
						number = to_string(count);
					}
					string pathConvex = "C:\\Projects\\Output\\file1\\correctX\\img_convex_" + number + ".jpg";
					string pathConvexMask = "C:\\Projects\\Output\\file1\\correctX\\img_cmask_" + number + ".jpg";
					string pathBox = "C:\\Projects\\Output\\file1\\correctX\\img_box_" + number + ".jpg";
					string pathFrame = "C:\\Projects\\Output\\file1\\correctX\\img_frame_" + number + ".jpg";

					count++;
					imwrite(pathConvex, contourRegionConvex);
					imwrite(pathConvexMask, contourRegionConvexMask);
					imwrite(pathBox, contourRegionBox);
					imwrite(pathFrame, originalFrame);

					////#*cvNamedWindow("contourRegionConvex", CV_WINDOW_NORMAL);
					////#*cvNamedWindow("contourRegionBox", CV_WINDOW_NORMAL);
					////#*("contourRegionConvexMask", CV_WINDOW_NORMAL);

					////*imshow("contourRegionConvex", contourRegionConvex);
					////*imshow("contourRegionBox", contourRegionBox);
					////*imshow("contourRegionConvexMask", contourRegionConvexMask);

					//cvResizeWindow("contourRegionBox", contourRegionBox.cols, contourRegionBox.rows); 
					/*cvResizeWindow("contourRegionConvex", contourRegionConvex.rows, contourRegionConvex.cols);
					cvResizeWindow("contourRegionBox", contourRegionBox.cols, contourRegionBox.rows);*/

					//imshow("Contour Drawing 2", contourRegion);
					//cvMoveWindow("Contour Drawing", 400,200);

				}
				else{
					imwrite("C:\\Projects\\Output\\file1\\nonX\\" + ts + to_string(i) + ".jpg", contourRegionConvex);


					//imshow("Contour Drawing 2", contourRegion);
					//cvMoveWindow("Contour Drawing", 400,200);

				}
			}

		}
	}
	return 0;
}

Mat drawHist(Mat greyImage)
{////
	float colourFrequency2[256] = {}; // u should give ={} bcos it will hav garbage values frm that array.
	for (int i = 0; i < greyImage.rows; i++){
		for (int j = 0; j < greyImage.cols; j++){
			int pixel = greyImage.at<uchar>(i, j);
			colourFrequency2[pixel] += 1;
		}
	}

	float max = 0.0;
	for (int i = 0; i < 256; i++){
		if (max < colourFrequency2[i]){
			max = colourFrequency2[i];
		}
	}
	Mat histogram2(310, 260, CV_8UC3, Scalar(255, 255, 255));

	int hist2[256] = {};
	float maxd = max;
	for (int i = 0; i < 256; i++){
		hist2[i] = cvRound(double(colourFrequency2[i] / maxd) * 300.0);
		Point pt1 = Point(i, 300 - hist2[i]);
		Point pt2 = Point(i, 300);
		line(histogram2, pt1, pt2, Scalar(0, 0, 0), 1, 8, 0);
	}

	return histogram2;

}